设计模式的7大原则：单一职责，接口隔离原则，开闭原则，里氏替换原则，
                依赖倒置原则，合成复用原则，迪米特法则
23种设计模式的类型：
    创建型（5）：单例（恶汉式，懒汉式（synchronic关键字式,双重null），内部类，枚举）
          简单工厂，
          抽象工厂，
          原型模式：实现对象的快速复制，而不是通过new的方法。java中有clone方法。
          建造者模式：组装零配件而产生一个新产品。

    结构型（7）：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
            适配器模式（包装器模式）是原有类的扩展：类适配器模式、对象适配器模式、接口适配器模式
            桥接模式：聚合关联关系建立在抽象层。桥接模式要求正确识别出系统中"两个独立变化的维度"
            装饰者模式：在装饰者类里面组合被装饰者属性，然后重写被装饰者方法以扩展。装饰模式是针对抽象组件（Component）类型编程
              装饰者模式为本装饰的对象进行功能扩展；代理模式对代理对象进行控制，但不做功能扩展
            组合模式：适合需要遍历组织机构，或者处理的对象具有树形结构时。整体与部分关系：抽象组件中添加add remove方法
            外观模式：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
            享元模式（蝇量模式）：通过一个hashmap保存一个对象，需要时直接从这个享元工厂获取
            代理模式：动态代理（利用反射,又叫JDK代理，接口代理），静态代理，cglib代理
                Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
                            @Override
                            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                return method.invoke(target,args);
                            }
                        });


    行为性（11）：状态模式，
          职责链模式，
          备忘录模式，
          解释器模式，
          策略模式
          中介模式
          观察者模式
          模版方法模式、命令模式、访问者模式、迭代器模式
          模版方法：抽象类中实现了模板方法(template)用final修饰，定义了算法的骨架，具体子类需要去实现。钩子方法
          命令模式：命令（聚合接收者），接收者，发布者（管理者），管理者里面使用空命令（防止null）
          访问者模式：解决数据结构和操作耦合性问题，方便新增数据的访问方式。
          迭代器模式：统一集合类的访问方式，需要为每个集合类整一个迭代器类，并在该集合类中提供一个获取该迭代器的方法，通过迭代器访问集合元素。
          观察者模式：观察者 被观察者 主题接口
          中介模式：通过中介来沟通几个同事，同事之前不互相沟通。同事类聚合中介者
          策略模式：将类中的变化（变化的属性）抽离出来，通过聚合的方式来设置不同的策略方式



行为模式：关注系统中"""对象之间"""的相互交互，研究系统在运行时""""对象之间的相互通信和协作"""，进一步明确对象的职责，共11种模式

结构型模式：描述如何将"""类和对象组合起来"""，形成更大的结构，就像搭积木，可以通过简单积木的组合形成复功能更为强大的积木。
    类结构模式 : 由多个类可以组成一个更大的系统，在类结构模式中只存在继承关系和实现关系
    对象结构模式 : 通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。

    根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此大部分结构模式都是对象结构模式