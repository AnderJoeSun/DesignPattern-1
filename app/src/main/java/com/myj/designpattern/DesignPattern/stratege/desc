策略模式：可以定义策略属性，以实现不同的策略实现。可以将类的方法抽象为行为类，这样就可以使用策略模式
可以将继承改为聚合或组合的方式。

传统的方式实现的问题分析和解决方案
    传统方案解决鸭子问题：抽象类 继承实现
    1) 其它鸭子，都继承了Duck类，所以fly让所有子类都会飞了，这是不正确的
    2) 上面说的1的问题，其实是继承带来的问题:对类的局部改动，尤其超类的局部改
    动，会影响其他部分。会有溢出效应
    3) 为了改进1问题，我们可以通过覆盖fly方法来解决=>覆盖解决
    4) 问题又来了，如果我们有一个玩具鸭子ToyDuck, 这样就需要ToyDuck去覆盖Duck
    的所有实现的方法 => 解决思路 策略模式 (strategy pattern)

基本介绍
    1) 策略模式(Strategy Pattern)中，定义算法族（"""策略族"""），分别封装起来，让他们之间可以 互相替换，此模式让算法的变化独立于使用算法的客户
    2) 这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来;
        第二、针对接口编程而不是具体类(定义了策略接口);
        第三、多用组合/聚合， 少用继承(客户通过组合方式使用策略)。


策略模式类图模型：
说明:从上图可以看到，客户context 有成员变量strategy或者其他的策略接口 ,
至于需要使用到哪个策略，我们可以在构造器中指定.


在sdk中应用：Comparator接口 lambda表达式实现。Comparator为策略接口，采用匿名内部类的方式


1) 策略模式的关键是:分析项目中变化部分与不变部分
2) 策略模式的核心思想是:多用组合/聚合少用继承;用行为类组合，而不是行为的继承。更有弹性
3) 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只 要添加一种策略(或者行为)即可，避免了使用多重转移语句(if..else if..else)
4) 提供了可以替换继承关系的办法: 策略模式将算法封装在独立的Strategy类中使得 你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展
5) 需要注意的是:每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大